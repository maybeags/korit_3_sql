# 입실 체크 해주세요! 🌭

# GROUP BY / HAVING

## GROUP BY - 데이터를 '그룹화'하는 구문
- 같은 값을 가지는 행들(rows)을 하나의 그룹으로 묶어 집계 함수를 적용할 수 있게 함.

## HAVING 
- WHERE은 그룹화 전에 개별 행에 조건을 걸고, _HAVING_은 그룹화 후의 결과에 조건을 걺.

|단계 | 구문 | 의미 |
|---|---|---|
|1 | FROM | 테이블 선택 |
|2 | WHERE | 개별 행 필터링 |
|3 | GROUP BY | 행들을 그룹화 |
|4 | HAVING | 그룹화된 결과 필터링 |
|5 | SELECT | 최종 출력 지정 |
|6 | ORDER BY | 정렬 |

### HAVING은 단독으로 쓸 수 없다. -> GROUP BY에 종속되어있음.
- `HAVING`은 그룹화된 집계 결과에 조건을 거는 방식


문제들

-- 2. 공급 업체별 등록 상품 개수가 3 개 이상인 것만 추출하세요.

-- 3. 공급 업체별 총 재고량이 100개 이상인 것만 추출하세요.

-- 4. 카테고리별 최고 가격이 50000원 초과인 카테고리를 출력하세요.

-- 5. 2024년 2월 이후에 입고된 상품들만 대상으로(WHERE) 공급 업체별 평균 가격이
-- 4만원 이상인 것만 추출하세요.

-- 6. 2024년 2월 이후에 입고된 상품들만 대상으로 카테고리별 평균 가격이
-- 3만원 이하인 것만 추출하세요.

-- 7. 생활가전 카테고리만 대상으로 공급업체별 총 재고가 50개 이상인 것만 추출하세요.

-- 8. TechMart, CleanLife 두 업체만 대상으로 공급 업체별 평균 가격이 20000원
-- 이하인 업체만 출력하세요.


# 풀이 및 현재 전체 코드 20250416 10:42
```sql
SELECT * FROM product_raw;

-- 1. 전체 평균 가격
SELECT AVG(price) AS 평균가격
	FROM product_raw;

-- 2. 가장 재고가 많은 상품의 수량
SELECT MAX(stock) AS 최대수량
	FROM product_raw;

-- Group By
-- 1. 카테고리별 평균 가격
SELECT category, AVG(price) AS 평균가격
	FROM product_raw
	GROUP BY category;

-- 해봤자 소용이 없는 예시 -> 왜? 어차피 각자 고유값을 들고 있기 때문에
SELECT *
	FROM product_raw
	GROUP BY product_id;

SELECT *
	FROM product_raw
	GROUP BY product_name;	-- 혹시나 같은 이름 가지고 있으면 얘는 겹치게 될 수도 있습니다.
	
-- 소용이 있는 예시로,
-- 2. 공급업체별 전체 물량 합을 표시할 것
SELECT supplier, SUM(stock) AS 업체별전체공급량
	FROM product_raw
	GROUP BY supplier
	ORDER BY SUM(stock) DESC;


-- 3. 공급업체별 등록된 상품 개수를 구하세요.
SELECT supplier, COUNT(stock) AS 업체별등록상품개수
	FROM product_raw
	GROUP BY supplier;
-- 4. 공급업체별 평균 재고량을 구하세요.
SELECT supplier, AVG(stock) AS 업체별평균공급량
	FROM product_raw
	GROUP BY supplier;
-- 5. 카테고리별 최저 가격을 구하세요.
SELECT category, MIN(price) AS 카테고리별최저가격
	FROM product_raw
	GROUP BY category;
-- 6. (저랑 풀겁니다) 입고 날짜 기준으로 월별 평균 가격을 구하세요.
SELECT MONTH(created_at) AS 월, AVG(price) AS 평균가격
	FROM product_raw
	GROUP BY MONTH(created_at);
-- GROUP BY 월; -> 이거는 DBMS별로 지원할 수도 있고 아닐 수도 있습니다.

-- HAVING 수업 파트
SELECT supplier, COUNT(stock) AS 업체별등록상품개수
	FROM product_raw
	GROUP BY supplier
	HAVING 업체별등록상품개수 > 1;	-- 얘도 DBMS별로 될 수도 있고 아닐 수도 있음.
-- 	HAVING COUNT(stock) > 1;
	
-- 1. 평균 가격이 4만원 이상인 카테고리만 추출하세요.
SELECT category, AVG(price) AS 평균가격
	FROM product_raw
	GROUP BY category
	HAVING 평균가격 >= 10000;

-- 2. 공급 업체별 등록 상품 개수가 3 개 이상인 것만 추출하세요.
SELECT supplier, COUNT(product_name) AS 상품개수
	FROM product_raw
	GROUP BY supplier
	HAVING 상품개수 >= 3;
-- 3. 공급 업체별 총 재고량이 100개 이상인 업체만 추출하세요.
SELECT supplier, SUM(stock) AS 총재고량
	FROM product_raw
	GROUP BY supplier
	HAVING 총재고량 >= 100
	ORDER BY 총재고량 DESC;
-- 4. 카테고리별 최고 가격이 50000원 초과인 카테고리를 출력하세요.
SELECT category, MAX(price) AS 50000원초과
	FROM product_raw
	GROUP BY category
	HAVING 50000원초과 > 50000;

-- 5. 2024년 2월 이후에 입고된 상품들만 대상으로(WHERE) 공급 업체별 평균 가격이
-- 4만원 이상인 것만 추출하세요.
SELECT supplier, AVG(price) AS 평균가격
	FROM product_raw
	WHERE created_at >= '2024-02-01'
	GROUP BY supplier
	HAVING 평균가격 >= 40000;
-- 6. 2024년 2월 이후에 입고된 상품들만 대상으로 카테고리별 평균 가격이
-- 3만원 이하인 카테고리만 추출하세요.
SELECT category, AVG(price) AS 평균가격
	FROM product_raw
	WHERE created_at >= '2024-02-01'
	GROUP BY category
	HAVING 평균가격 <= 30000;
-- 7. 생활가전 카테고리만 대상으로 공급업체별 총 재고가 50개 이상인 
-- 공급업체만 추출하세요.
SELECT supplier, SUM(stock) AS 총재고
	FROM product_raw
	WHERE category = '생활가전'
	GROUP BY supplier
	HAVING 총재고 >= 50;
-- 8. TechMart, CleanLife 두 업체만 대상으로 공급 업체별 평균 가격이 20000원
-- 이하인 공급업체만 출력하세요.
SELECT supplier, AVG(price) AS 평균가격
	FROM product_raw
	WHERE supplier IN ('TechMart', 'CleanLife')	-- OR 쓰셔도 됩니다.
	GROUP BY supplier
	HAVING 평균가격 <= 20000;
```

# 정규화 수업
table명 order_raw
    order_id INT,
    order_date DATE,
    customer_name VARCHAR(100),
    customer_phone VARCHAR(20),
    customer_address VARCHAR(200),
    product_name VARCHAR(100),
    product_price INT,
    quantity INT

1001, 2024-04-10 김영희 010-1234-5678 서울시 강남구 무선마우스 25000 2
1001, 2024-04-10 김영희 010-1234-5678 서울시 강남구 키보드  50000 1
1002, 2024-04-11 이철수 010-9876-1234 부산시 해운대구 USB 케이블 10000 3

## 정규화 이전의 문제점
- 현재 상태에서 데이터를 관리하게 됐을 때 생각해볼 수 있는 문제점은 무엇인가?
  - 이를 이상현상(anomaly)
### 삽입 이상(Insertion Anomaly)
- 상품은 존재하지만, 아무도 주문하지 않은 경우에 상품 정보를 저장하는 것이 불가능
  - 보조배터리라는 상품이 새로 등록되었더라도 주문이 없으면 order_raw 테이블에 추가할 수 없습니다.

### 삭제 이상(Deletion Anomaly)
- 이철수가 주문한 상품이 하나 뿐인데, 주문을 삭제하면 고객 정보가 전체 삭제됩니다.

### 갱신 이상(Update Anomaly)
- 김영희의 주소가 변경되었을 때, 복수의 row를 모두 수정해야 합니다. 하나라도 빼먹고 수정하면 정보가 불일치하게 되어 동명이인인건지 ID가 같으니까 같은 사람인건지 혹은 ID가 주문 정보에 대한 ID인건지에 대한 혼란이 오게 됩니다.

### 중복(Redundancy)
- 현재 확인했을 때 같은 고객 정보가 여러 번 반복되고, 같은 상품도 주문 등록을 했을 경우에 가격과 이름 등이 반복될 수 있습니다.

## 그렇다면 정규화(Normalization)란?
- 데이터베이스 설계 시, 데이터를 _중복 없이 효율적으로 구성하고, 삽입/삭제/갱신 등의 이상_을 방지하기 위해 테이블을 구조적으로 정리하는 과정

- 정규화는 단순히 테이블을 다 쪼개는 것이 아니라, 데이터 간의 의미 있는 종속 관계(함수 종속)를 바탕으로 불필요한 데이터를 바탕으로, '무결성'을 보장하며, 유지보수성을 높이기 위한 설계 전략에 해당함.

- 실무 상에서는 1정규화 - 3정규화까지 자주 쓰이는데, 시험 상황에서는 BCNF, 4정규화 등의 특징을 객관식으로 내는 경우가 있습니다.


customer
  customer_id INT
  customer_name varchar(100)
  customer_phone varchar(20)
  customer_address varchar(200)
product
  product_id INT
  product_name varchar(100)
  product_price INT
orders
  order_id INT
  order_date DATE
  customer_id INT (얘가 나중에 외래키)
order_item
  order_id INT  (얘 외래키)
  product_id INT (얘 외래키)
  quantity INT


# PK vs. FK

## 1. PK(기본키 : Primary Key)
- 한 테이블 안에서 각 행(row)을 고유하게 구별하기 위한 식별자.
  - DB 상에서 해당 row는 다른 어떤 row들과 겹치지 않다고 증명하는 column에 해당함.

  customer tb -> customer_id
  product tb -> product_id
  orders tb -> order_id

### PK의 조건
1. 고유함 : 중복된 값이 있으면 x
2. NULL 불가 : 값이 반드시 있어야만 함.
3. 테이블당 하나만 존재 : PK는 한 테이블에 하나만 '지정' 가능

## 2. FK(외래키 : Foreign Key)
- 외래키는 다른 테이블의 _기본키(Primary Key)를 참조_하는 column
  - 두 개의 테이블이 서로 연결되도록 만들어주는 역할

### FK의 역할
1. 두 테이블 간의 관계를 형성
2. 참조 무결성을 유지
  - 없는 학생에게 성적을 주는 것이 불가능
    - grade tb가 있고, student tb이 있을 때 grade tb가 student_id 컬럼을 가지고 있다면, student_id가 없는 row에 값을 주는 것이 불가능해진다.

  - 학생이 전학 등의 이유로 정보가 삭제되었을 때 성적이 함께 날아가는 경우를 막을 수 있음

## PK / FK의 필요성
### PK가 없다면
- 행을 고유하게 구분할 수 없음
- 중복된 데이터가 쌓이더라도 구분할 수 없음
- `UPDATE` / `DELETE` 수행시 어떤 데이터를 수정 및 삭제할지 명확하지 않음

### FK가 없다면
- 관계가 없는 테이블끼리 마음대로 연결할 수 있음(기준이 없기 때문에)
- 없는 고객에게 주문을 넣는 것이 가능해짐
- 이상을 이유로 _데이터의 무결성(Integrity)_ 이 깨짐

#### Primary Key 지정하는 SQL문(테이블 생성시)
```sql
CREATE TABLE customer (
  cutomer_id INT PRIMARY KEY,
  name VARCHAR(100)
);
```
라는 SQL문이 있을 때 두 개의 column(customer_id / name)을 지니고 있으면서 customer_id가 PK 지정이 되었다고 해석할 수 있음. -> 테이블을 만들 때.

#### Foreign Key 지정하는 SQL문(테이블 생성시)
```sql
CREATE TABLE orders (
  order_id INT PRIMARY KEY,
  customer_id INT,
    FOREIGN KEY(customer_id) REFERENCES customer(customer_id)
);
```